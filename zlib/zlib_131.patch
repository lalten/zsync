diff --git a/deflate.c b/deflate.c
index 012ea81..9ee79da 100644
--- a/deflate.c
+++ b/deflate.c
@@ -1202,7 +1202,6 @@ int ZEXPORT deflate(z_streamp strm, int flush) {
         }
         if (bstate == block_done) {
             if (flush == Z_PARTIAL_FLUSH) {
-                _tr_align(s);
             } else if (flush != Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */
                 _tr_stored_block(s, (char*)0, 0L, 0);
                 /* For a full flush, this empty block will be recognized
diff --git a/inflate.c b/inflate.c
index 94ecff0..7785104 100644
--- a/inflate.c
+++ b/inflate.c
@@ -6,6 +6,12 @@
 /*
  * Change history:
  *
+ * cph          26 Oct 2004
+ * - A few minor hacks to allow me to locate safe start points in streams
+ *   and to position a new inflate on the right bit. I hereby place any 
+ *   changes to this file (and the zlib.h and inflate.h in this dir) into 
+ *   the public domain.
+ *
  * 1.2.beta0    24 Nov 2002
  * - First version -- complete rewrite of inflate to simplify code, avoid
  *   creation of window when not needed, minimize use of window when it is
@@ -83,7 +89,6 @@
 #include "zutil.h"
 #include "inftrees.h"
 #include "inflate.h"
-#include "inffast.h"
 
 #ifdef MAKEFIXED
 #  ifndef BUILDFIXED
@@ -365,7 +370,7 @@ void makefixed(void)
    output will fall in the output data, making match copies simpler and faster.
    The advantage may be dependent on the size of the processor's data caches.
  */
-local int updatewindow(z_streamp strm, const Bytef *end, unsigned copy) {
+int updatewindow(z_streamp strm, const Bytef *end, unsigned copy) {
     struct inflate_state FAR *state;
     unsigned dist;
 
@@ -1024,15 +1029,10 @@ int ZEXPORT inflate(z_streamp strm, int flush) {
             state->mode = LEN;
                 /* fallthrough */
         case LEN:
-            if (have >= 6 && left >= 258) {
-                RESTORE();
-                inflate_fast(strm, out);
-                LOAD();
-                if (state->mode == TYPE)
-                    state->back = -1;
-                break;
-            }
-            state->back = 0;
+            /* cph - remove inflate_fast */
+            state->mode = LENDO;
+            goto inf_leave;
+        case LENDO:
             for (;;) {
                 here = state->lencode[BITS(state->lenbits)];
                 if ((unsigned)(here.bits) <= bits) break;
@@ -1524,3 +1524,42 @@ unsigned long ZEXPORT inflateCodesUsed(z_streamp strm) {
     state = (struct inflate_state FAR *)strm->state;
     return (unsigned long)(state->next - state->codes);
 }
+
+/* cph 2004/10/17 
+ * Extra stuff I need to move around in gzip files
+ */
+
+void inflate_advance(z_streamp strm, int zoffset, int b, int s)
+{
+  struct inflate_state FAR* state = (struct inflate_state FAR *)strm->state;
+
+  if (s)
+    state->mode = TYPEDO;
+  else if (state->mode == COPY) {
+    /* Reduce length remaining to copy by correct number */
+    state->length -= zoffset - strm->total_in;
+  } else
+    state->mode = LENDO;
+
+  strm->total_in = zoffset; /* We are here, plus a few more bits. */
+
+  if (b) {
+    state->hold = *(strm->next_in)++;
+    state->hold >>= b;
+    state->bits = 8-b;
+    strm->avail_in--;
+    strm->total_in++;
+  } else {
+    state->bits = 0;
+    state->hold = 0;
+  }
+}
+
+int ZEXPORT inflateSafePoint(z_streamp strm)
+{
+    struct inflate_state FAR *state;
+
+    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
+    state = (struct inflate_state FAR *)strm->state;
+    return (state->mode == LENDO || state->mode == COPY);
+}
diff --git a/inflate.h b/inflate.h
index f127b6b..8f49e8d 100644
--- a/inflate.h
+++ b/inflate.h
@@ -39,6 +39,7 @@ typedef enum {
         CODELENS,   /* i: waiting for length/lit and distance code lengths */
             LEN_,       /* i: same as LEN below, but only first time in */
             LEN,        /* i: waiting for length/lit/eob code */
+            LENDO,      /* i: same, but skip exit check */
             LENEXT,     /* i: waiting for length extra bits */
             DIST,       /* i: waiting for distance code */
             DISTEXT,    /* i: waiting for distance extra bits */
diff --git a/zlib.h b/zlib.h
index 8d4b932..7d6c91d 100644
--- a/zlib.h
+++ b/zlib.h
@@ -1448,7 +1448,6 @@ ZEXTERN z_size_t ZEXPORT gzfread(voidp buf, z_size_t size, z_size_t nitems,
    file, resetting and retrying on end-of-file, when size is not 1.
 */
 
-ZEXTERN int ZEXPORT gzwrite(gzFile file, voidpc buf, unsigned len);
 /*
      Compress and write the len uncompressed bytes at buf to file. gzwrite
    returns the number of uncompressed bytes written or 0 in case of error.
@@ -1775,6 +1774,8 @@ ZEXTERN uLong ZEXPORT crc32_combine_op(uLong crc1, uLong crc2, uLong op);
    crc32_combine() if the generated op is used more than once.
 */
 
+ZEXTERN int ZEXPORT updatewindow(z_streamp strm, const Bytef *end, unsigned copy);
+ZEXTERN void ZEXPORT inflate_advance(z_streamp strm, int zoffset, int b, int s);
 
                         /* various hacks, don't look :) */
 
@@ -1913,6 +1914,7 @@ ZEXTERN int ZEXPORT gzgetc_(gzFile file);       /* backward compatibility */
 /* undocumented functions */
 ZEXTERN const char   * ZEXPORT zError(int);
 ZEXTERN int            ZEXPORT inflateSyncPoint(z_streamp);
+ZEXTERN int            ZEXPORT inflateSafePoint(z_streamp);
 ZEXTERN const z_crc_t FAR * ZEXPORT get_crc_table(void);
 ZEXTERN int            ZEXPORT inflateUndermine(z_streamp, int);
 ZEXTERN int            ZEXPORT inflateValidate(z_streamp, int);
